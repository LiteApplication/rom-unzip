#!/usr/bin/python3
#Modules import
import argparse
import os
import sdat2img
from termcolor import colored
from pwd import getpwuid
from grp import getgrgid
import json
import glob
import shutil
import sys
import zipfile
#Argument parser
ap = argparse.ArgumentParser(description="Unzip an Android rom to system.img and vendor.img. ")
ap.add_argument("-v","--version",     action="store_true", help="Show the script version and exit. ")
ap.add_argument("-V","--verbose",     action="store_true", help="Verbosely run script. ")
ap.add_argument("-l","--log",         action="store_true", help="Save output to rom-unzip.log. ")
ap.add_argument("-a","--all",         action="store_true", help="Run all steps, enabled by default. ")
ap.add_argument("-u","--update",      action="store_true", help="Update program and exit. ")
ap.add_argument("-r","--resume",      action="store_true", help="Resume previous rom extracting. ")
ap.add_argument("-s","--show-saved",  action="store_true", help="Show the actual saved state and exit. ")
ap.add_argument("-p","--rom-path",    action="store",      help="The path to rom.zip folder. ",                             dest='path',    default=".")
ap.add_argument("-m","--step",        action="store",      help="Run only one step of rom-unzip. Pass 0 to view options. ", dest='step',    default="-1",  type=int, )
ap.add_argument("-o","--option",      action="store",      help="Argument for single step.",                                dest='opt',     default="")
ap.add_argument("-e","--extract-dir", action="store",      help="Path to extract rom. ",                                    dest='extract', default="rom-extracted")


args = ap.parse_args()
if args.step == -1:
    args.all = True
else:
    args.all = False

class rom_toolbox:
    __doc__ = """This class is a toolbox for rom_unzip\n"""
    def select(self, runDir="NoDir"): #return a rom zip (absolute path) from runDir
        show("Start rom_toolbox.select()")
        if runDir=="NoDir":
            runDir=os.getcwd()
            show("No command, selecting cwd")
        ROM_FILES=['system.new.dat.br','vendor.new.dat.br','system.transfer.list','vendor.transfer.list']
        show("Finding ROM zip file...")
        availableZip=glob.glob(runDir+"/*.zip")
        availableRom=[]
        for zipp in availableZip:
            zipf = zipfile.ZipFile(zipp)
            add=False
            for file in ROM_FILES:
                if file in zipf.namelist():
                    add=True
            if add:
               availableRom.append(zipp)
        if len(availableRom)>= 2:
            print("Multiple ROMs are available in this directory : ")
            rom=self.chooseFile(availableRom)
        elif availableRom==[]:
            return "NOROM"
        else:
            rom=availableRom[0]
        return rom
    def unzip(self, source,path):
        show("Extracting rom files...")
        zipfile.ZipFile(source, 'r').extractall(path)
    def unbr(self, source,path):
        os.system("brotli -d " + source + " -o " + path + "> /dev/null")
    def chooseFile(self, files):
        for i,file in zip(range(1,len(files)),files):
            print("\t"+str(i)+" : "+os.path.splitext(os.path.basename(file))[0])
        print("\n\t0 : Exit")
        try:
            choice = int(input("Your choice : "))-1
        except ValueError:
            print("Wrong entry type, press 0 to exit")
            self.chooseFile(files)
        if choice == -1:
            print("Exiting...")
            exit(0)
        else:
            return files[choice]
    def listFiles(rootdir):
        for (cur,subdir,files) in os.walk('Test', topdown=true): 
            for element in subdir+files:
                yield cur + "/" + element

class rom_unzip:
    __doc__ = """This class allow you to extract Android Roms into system and vendor folders."""
    __version__ = 0.6
    def run_all(self):
        self.import_modules()
        rom = self.select_rom(args.path)
        self.create_dir(args.extract)
        self.set_state(3, ".")
        self.unzip_rom(rom)
        self.set_state(4, ".")
        self.unzip_broti()
        self.set_state(5, ".")
        self.extract_dat()
        self.set_state(6, ".")
        self.save_img()
        self.set_state(7, ".")
        self.copy_img()
        self.set_state(8, ".")
    def show_steps():
        print("0 : self.show_steps")
        print("1 : self.import_modules,")
        print("2 : self.select_rom,")
        print("3 : self.create_dir,")
        print("4 : self.unzip_rom,")
        print("5 : self.unzip_brotli,")
        print("6 : self.extract_dat,")
        print("7 : self.save_img,")
        print("8 : self.copy_img")
    def run_step(self,n):
        steps = {
            0 : self.show_steps,
            1 : self.import_modules,
            2 : self.select_rom,
            3 : self.create_dir,
            4 : self.unzip_rom,
            5 : self.unzip_brotli,
            6 : self.extract_dat,
            7 : self.save_img,
            8 : self.copy_img
        }
        if args.OPTION == "":
            steps[n]()
        else:
            steps[n](args.OPTION)
    def import_modules(self):
        try:
            show("Importing python files...")
        except ImportError:
            print("E05: ImportError")
            exit(1)
    def select_rom(self, romdir):
        rompath=tb.select(path(romdir))
        if rompath=="NOROM":
            print(colored("E02 : NoRomError, Please cd to the rom.zip folder","red"))
            exit(1)
        if not os.path.isfile(rompath):
            print(colored("E03 : NotFileError, The selected ROM is not a file (" + rompath + ").Please cd to the rom.zip folder and select it. ","red"))
            exit(1)
        return rompath
    def create_dir(self, extract):
        try:
            os.mkdir(extract,0o777)
        except FileExistsError:
            shutil.rmtree(extract)
            os.mkdir(extract,0o777)
            pass
        os.chdir(path(extract))
    def unzip_rom(self, rompath):
        tb.unzip(path(rompath),path("."))
    def unzip_brotli(self):
        show("Extracting system.new.dat.br...")
        tb.unbr(path("system.new.dat.br"),"system.new.dat")
        show("Extracting vendor.new.dat.br...")
        tb.unbr(path("vendor.new.dat.br"),"vendor.new.dat")
    def extract_dat(self):
        sdat2img.extract(path("system.new.dat"),path("system.transfer.list"),"system.img")
        sdat2img.extract(path("vendor.new.dat"),path("vendor.transfer.list"),"vendor.img")
    def save_img(self):
        show("Mounting system.img ...")
        os.system("mkdir system.dir")
        os.system("sudo mount -t ext4 -o loop system.img system.dir/")
        show("Mounting vendor.img ...")
        os.system("mkdir vendor.dir")
        os.system("sudo mount -t ext4 -o loop vendor.img vendor.dir/")
        show("Analysing system...")
        if os.path.exists("/SYSTEM_PERMISSIONS"):
            os.remove(path("/SYSTEM_PERMISSIONS"))
        permissions=open("./SYSTEM_PERMISSIONS","a+")
        FilesNb = sum([len(files) for r, d, files in os.walk("system.dir")])
        permissions.write("### Files and folders : " + FilesNb + " ###\n")
        show("Saving permissions for system...")
        lf=tb.listFiles(path("system.dir"))
        show("Saving permissions for system...")
        for path,progress in zip(lf,range(1,FilesNb)):
            permissions.write(json.dumps([path,oct(stat.st_mode)[-3:],getpwuid(stat.st_uid).pw_name,getgrgid(stat.st_gid).gr_name]))
        permissions.close()
        show("Analysing vendor...")
        if os.path.exists("/VENDOR_PERMISSIONS"):
            os.remove(path("/VENDOR_PERMISSIONS"))
        permissions=open("./VENDOR_PERMISSIONS","a+")
        FilesNb = sum([len(files) for r, d, files in os.walk("vendor.dir")])
        permissions.write("### Files and folders : " + FilesNb + " ###\n")
        show("Saving permissions for vendor...")
        lf=tb.listFiles(path("vendor.dir"))
        show("Saving permissions for vendor...")
        for path,progress in zip(lf,range(1,FilesNb)):
            permissions.write(json.dumps([path,oct(stat.st_mode)[-3:],getpwuid(stat.st_uid).pw_name,getgrgid(stat.st_gid).gr_name]))
        permissions.close()
    def copy_img(self):
        os.mkdir("system.rw")
        os.mkdir("vendor.rw")
        show("Copying files to system.rw")
        os.system("cp -R system.dir/* system.rw/")
        show("Copying files to vendor.rw")
        os.system("cp -R vendor.dir/* vendor.rw/")
    def set_state(self, state, dest):
        if not os.path.exists():
            os.mknod(dest+"/.state.save")
        with open(dest+"/.state.save","w+") as f:
            f.write(str(state))
    def get_state(self, dest):
        with open(dest+"/.state.save","r+") as f:
            return str(f.readline())

def show(message):
    if args.verbose:
        print(message)
    if args.log:
        with open("./rom-unzip-logs.txt","a") as f:
            f.write(message+" \r\n")
def path(s):
    return os.path.abspath(glob.glob(s)[0])
if os.geteuid() != 0:
    print("Please run this script as root\nwith 'sudo "+sys.argv[0]+"'")
    print("CODE : 1")
    exit(1)
try:
    show("Rom-unzip by LiteApplication verion " + str(rom_unzip.__version__))
    show("Step      : " + str(args.step))
    show("Log       : " + str(args.log))
    show("Verbose   : " + str(args.verbose))
    show("All       : " + str(args.all))
    show("Version   : " + str(args.version))
    show("Resume    : " + str(args.resume))
    show("Update    : " + str(args.update))
    show("Saved     : " + str(args.show_saved))
    show("Option    : " + str(args.opt))
    show("Rom path  : " + str(args.path))
    show("Extract   : " + str(args.extract))
    ru = rom_unzip()
    tb = rom_toolbox()
    if args.version:
        print("Rom-unzip by LiteApplication verion " + str(rom_unzip.__version__))
        exit(0)
    elif args.update:
        os.system("curl -s https://raw.githubusercontent.com/LiteApplication/rom-unzip/master/install | sudo bash")
        exit(0)
    elif int(args.step) > -1 and int(args.step) <= 8:
        ru.run_step(args.step)
    elif int(args.step) <= -1 and int(args.step) > 9:
        ru.run_all()
    elif args.all:
        ru.run_all()
except KeyboardInterrupt:
    show("Exiting...")
    exit(0)

